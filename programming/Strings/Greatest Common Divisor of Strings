https://leetcode.com/problems/greatest-common-divisor-of-strings/description/?envType=study-plan-v2&envId=leetcode-75
=====================================================================


class Solution {
    public String gcdOfStrings(String str1, String str2) {

        
        if(str1.length()<str2.length())
        {
            return gcdOfStrings(str2,str1);
        }
        else if(!str1.startsWith(str2))
        {
            return "";
        }
        else if(str2.isEmpty())
        {
            return str1;

        }
        else {
           return gcdOfStrings(str1.substring(str2.length()),str2);
        }

    }
}

======================================================================

You are given two strings:

str1 and str2


You want to find the largest string that:

Can be repeated again and again

To make both str1 and str2

Example
str1 = "ABCABC"
str2 = "ABC"


Answer:

"ABC"


Because:

"ABC" + "ABC" = "ABCABC"

"ABC" also makes "ABC"

ðŸ§  Simple idea behind the solution

Think of strings like lego blocks.

You are asking:

â€œIs there a small lego block that can build both big lego towers?â€

ðŸ§© The Code (Step-by-step Explanation)
class Solution {
    public String gcdOfStrings(String str1, String str2) {


ðŸ‘‰ This function returns the biggest common building block string.

ðŸ” Step 1: Make sure str1 is the bigger string
if (str1.length() < str2.length()) {
    return gcdOfStrings(str2, str1);
}


ðŸ“Œ Plain English:

â€œIf str1 is shorter than str2, swap them.â€

Why?

Itâ€™s easier to cut from the bigger string

Same logic as division: divide the bigger number first

âŒ Step 2: Check if str2 fits at the start of str1
else if (!str1.startsWith(str2)) {
    return "";
}


ðŸ“Œ Plain English:

â€œIf the bigger string does NOT start with the smaller string,
then there is NO common block.â€

Example:

str1 = "ABCD"
str2 = "AB"


âœ” starts with â†’ OK

But:

str1 = "ABCD"
str2 = "AC"


âŒ does NOT start with â†’ impossible

So return:

""

ðŸ Step 3: If the smaller string is empty
else if (str2.isEmpty()) {
    return str1;
}


ðŸ“Œ Plain English:

â€œIf the second string is empty,
then whatever is left in str1 is the answer.â€

Why?

We have successfully removed all matching parts

What remains is the GCD string

âœ‚ï¸ Step 4: Cut and repeat (important part)
else {
    return gcdOfStrings(
        str1.substring(str2.length()),
        str2
    );
}


ðŸ“Œ Plain English:

â€œSince str1 starts with str2,
remove str2 from the front of str1
and try again.â€

Example:

str1 = "ABCABC"
str2 = "ABC"


After cutting:

str1 = "ABC"
str2 = "ABC"


Then:

str1 = ""
str2 = "ABC"


Eventually we reach the answer.

ðŸ§  How recursion helps (kid version)

It keeps asking:

â€œCan I remove this block again?â€
â€œCan I remove this block again?â€

Until:

Either it fails â†’ return ""

Or it perfectly fits â†’ return the block

ðŸ§ª Full Example Walkthrough
Input
str1 = "ABABAB"
str2 = "AB"


Steps:

"ABABAB" starts with "AB" â†’ cut

"ABAB" starts with "AB" â†’ cut

"AB" starts with "AB" â†’ cut

"" left â†’ return "AB"

âœ… Answer: "AB"

ðŸŽ¯ One-line explanation (child-friendly)

â€œWe keep removing the smaller string from the bigger one until nothing is left. If it always fits, that string is the answer.â€
