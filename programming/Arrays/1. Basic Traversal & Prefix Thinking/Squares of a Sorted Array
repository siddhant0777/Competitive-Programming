Squares of a Sorted Array
============================

class Solution {
    public int[] sortedSquares(int[] nums) {
        
        int left=0;
        int right=nums.length-1;
        int pos=nums.length-1;
        int[] result= new int[nums.length];

        while(left<=right){
            int leftSquare= nums[left]*nums[left];
            int rightSquare= nums[right]*nums[right];

            if(leftSquare>rightSquare){
                result[pos]=leftSquare;
                left++;
            }
            else{
                result[pos]=rightSquare;
                right--;
            }
         pos--;
        }
       return result; 
    }
}

====================

You are given a sorted array nums (may contain negative numbers).

Example:

nums = [-4, -1, 0, 3, 10]


If you square each number:

[16, 1, 0, 9, 100]


This is not sorted.

The goal is to return:

[0, 1, 9, 16, 100]


➡️ squares in sorted order.

Key idea (important!)

The largest square will come from:

the leftmost negative number, or

the rightmost positive number

So we compare both ends and place the bigger square at the end of result array

This is called the two-pointer approach.

Variables explained
int left = 0;
int right = nums.length - 1;
int pos = nums.length - 1;
int[] result = new int[nums.length];

Variable	Meaning
left	Points to start of array
right	Points to end of array
pos	Position where next biggest square goes
result	Final sorted squares array
How the while loop works
while (left <= right) {


Keep running until both pointers cross each other.

Step inside the loop
1️⃣ Square both ends
int leftSquare = nums[left] * nums[left];
int rightSquare = nums[right] * nums[right];


We square:

number at left

number at right

2️⃣ Compare squares
if (leftSquare > rightSquare) {
    result[pos] = leftSquare;
    left++;
}


If left square is bigger:

put it at the end of result

move left pointer forward

else {
    result[pos] = rightSquare;
    right--;
}


Otherwise:

put right square at the end

move right pointer backward

3️⃣ Move pos backward
pos--;


Because we just filled one position from the back

Example walkthrough
Input:
nums = [-4, -1, 0, 3, 10]

Execution:
left	right	left²	right²	 result
-4	    10	    16	     100	  [_, _, _, _, 100]
-4	    3	    16	      9	      [_, _, _, 16, 100]
-1	    3	    1	      9	      [_, _, 9, 16, 100]
-1	    0	    1	      0	      [_, 1, 9, 16, 100]
0	    0	    0	      0	      [0, 1, 9, 16, 100]

Final Output
[0, 1, 9, 16, 100]

Why this approach is efficient?

No sorting needed

Single loop

Time complexity: O(n)

Space complexity: O(n)
