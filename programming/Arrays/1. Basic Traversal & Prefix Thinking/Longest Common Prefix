https://leetcode.com/problems/longest-common-prefix/description/
================================================================

class Solution {
    public String longestCommonPrefix(String[] strs) {

        String prefix= strs[0];

        if(strs.length==0){
            return "";
        }

        else{
            for(int i=1;i<strs.length;i++){
                while(strs[i].indexOf(prefix)!=0){
                    prefix=prefix.substring(0,prefix.length()-1);
                }
            }
        }
        return prefix;
    }
}


=================================================

We are given some words, for example:

["flower", "flow", "flight"]


We must find the longest common prefix.

ðŸ‘‰ Prefix means:

Letters from the start of the word

Common prefix here is:

"fl"

Step-by-step explanation of the code
1ï¸âƒ£ Method signature
public String longestCommonPrefix(String[] strs) {


This method:

Takes an array of strings

Returns one string â†’ the common prefix

2ï¸âƒ£ First safety check (âš ï¸ small improvement needed)
if(strs.length == 0){
    return "";
}


ðŸ‘‰ If there are no words, there canâ€™t be any common prefix.

So we return:

""


âš ï¸ NOTE: In your code, this check should be before using strs[0]
Otherwise it may throw an error.

3ï¸âƒ£ Start by assuming the first word is the prefix
String prefix = strs[0];


ðŸ‘‰ Think like a child:

â€œThe longest possible common prefix cannot be longer than the first word.â€

So we start by assuming:

prefix = "flower"

4ï¸âƒ£ Compare prefix with each word one by one
for(int i = 1; i < strs.length; i++){


We start from index 1 because:

prefix already came from strs[0]

5ï¸âƒ£ The heart of the logic (VERY IMPORTANT)
while(strs[i].indexOf(prefix) != 0){


Letâ€™s understand this slowly.

The confusing line
while (strs[i].indexOf(prefix) != 0) {


You read it as:

while (flow.indexOf(flower) != 0)


And youâ€™re thinking:

â€œHow can â€˜flowerâ€™ be inside â€˜flowâ€™ ? ðŸ¤¯â€

That confusion is 100% valid.

First: What does indexOf() really do?
Simple rule ðŸ‘‡
string.indexOf(substring)


Means:

â€œAt which position does substring start inside string?â€

Examples
"flower".indexOf("flo")  â†’ 0
"flower".indexOf("wer")  â†’ 3
"flower".indexOf("abc")  â†’ -1


â— If substring does not exist, result is -1.

Now letâ€™s go step-by-step with your example
Input:
["flower", "flow", "flight"]

Step 1ï¸âƒ£ prefix is set
prefix = "flower"

Step 2ï¸âƒ£ Compare with "flow"

The condition becomes:

while ("flow".indexOf("flower") != 0)

What is this asking?

â€œDoes flow start with flower?â€

Does "flow" contain "flower"?

âŒ NO â€” "flower" is longer

So:

"flow".indexOf("flower") = -1


And:

-1 != 0   â†’ true


ðŸ‘‰ So while loop enters

Step 3ï¸âƒ£ Shrink the prefix
prefix = prefix.substring(0, prefix.length() - 1);


Now:

prefix = "flowe"

Check again
"flow".indexOf("flowe") = -1


Still:

-1 != 0 â†’ true


Shrink again:

prefix = "flow"

Check again
"flow".indexOf("flow") = 0


Now:

0 != 0 â†’ false


ðŸšª Loop stops

So what does this while loop REALLY mean?
In plain English ðŸ§ 
while (currentWord does NOT start with prefix) {
    shorten prefix
}

Why != 0 and not == -1?

Because:

We donâ€™t care where it exists

We care only if it starts at position 0

Position 0 = start of string âœ…

One mental trick to remember forever â­
indexOf(prefix) == 0


Means:

startsWith(prefix)

In fact, this could be written more clearly as:

while (!strs[i].startsWith(prefix)) {
    prefix = prefix.substring(0, prefix.length() - 1);
}


(Same logic, easier to read)
